
(**

{1 VerifyThis @ ETAPS 2016 competition, Challenge 2: Binary Tree Traversal}

{h

The following is the original description of the verification task,
reproduced verbatim from
<a href="http://http://etaps2016.verifythis.org/challenges">the competition web site</a>

<pre>

Challenge 2: Binary Tree Traversal

Consider a binary tree:

  class Tree {
    Tree left, right, parent;
    bool mark;
  }

We are given a binary tree with the following properties:
It is well formed, in the sense that following a child pointer (left or right) and then following a parent pointer brings us to the original node. Moreover, the parent pointer of the root is null.
It has at least one node, and each node has 0 or 2 children.
We do not know the initial value of the mark fields.

Our goal is to set all mark fields to true. The algorithm below (Morris 1979) works in time linear in the number of nodes, as usual, but uses only a constant amount of extra space.

  void markTree(Tree root) {
    Tree x, y;
    x = root;
    do {
          x.mark = true;
          if (x.left == null && x.right == null) {
                  y = x.parent;
          } else {
                y = x.left;
                x.left = x.right;
                x.right = x.parent;
                x.parent = y;
          }
          x = y;
    } while (x != null);
  }

Tasks. Prove that:
upon termination of the algorithm, all mark fields are set
the tree shape does not change
the code does not crash, and
the code terminates.

As a bonus, prove that the nodes are visited in depth-first order
</pre>}

The following is a solution by Martin Clochard (Universit√© Paris-Sud)
who entered the competition.

*)

(** Component-as-array memory model with null pointers. *)
module Memory

  use map.Map
  (** `loc` is the type of memory locations (e.g pointers) *)
  type loc
  val predicate eq (x y:loc) ensures { result <-> x = y }
  (** Kinds of pointer fields. *)
  type kind = Parent | Left | Right
  (** Convenience alias for a pointer field table. *)
  type pmem = map kind (map loc loc)
  type memory = abstract {
    mutable accessor : pmem;
    mutable mark : map loc bool;
  }
  (** `memo` represent memory. *)
  val memo : memory
  (** the memory model has a `null` pointer. *)
  constant null : loc
  val null () : loc ensures { result = null }
  val is_null (l:loc) : bool ensures { result <-> l = null }
  (** Memory getter & setters. non-null preconditions to
      check absence of null pointer access. *)
  val get_mark (l:loc) : bool
    requires { l <> null }
    reads { memo }
    ensures { result = memo.mark[l] }
  val set_mark (l:loc) (b:bool) : unit
    requires { l <> null }
    writes { memo.mark }
    ensures { memo.mark = (old memo).mark[l <- b] }
  val get_acc (p:kind) (l:loc) : loc
    requires { l <> null }
    reads { memo }
    ensures { result = memo.accessor[p][l] }
  val set_acc (p:kind) (l d:loc) : unit
    requires { l <> null }
    writes { memo.accessor }
    ensures { memo.accessor =
      (old memo).accessor[p <- (old memo).accessor[p][l <- d]] }
  (** Ghost global accessors. Those are technical tools
      to create ghost witnesses of past states. *)
  val ghost get_all_accs () : pmem
    reads { memo }
    ensures { result = memo.accessor }
  val ghost get_all_marks () : map loc bool
    reads { memo }
    ensures { result = memo.mark }

  (** Non-deterministic initialization. In the original alorithm,
      the variable y starts uninitialized. *)
  type non_det_magic
  type non_det = abstract { mutable non_det_field : non_det_magic }
  val non_det : non_det
  val anyloc () : loc writes { non_det }

end

(** In module `TreeShape` we describe the correlation between
    the memory and the binary tree model. We also gives
    elements of the algorithm specification, and prove
    some frame/separation properties. *)
module TreeShape

  use int.Int
  use set.Set
  use map.Map
  use bintree.Tree
  use bintree.Size
  use Memory

  (** The described structure can be modeled as a tree of locations *)
  type treel = tree loc

  (** `is_tree memo t c p` describe the fact that `c` points to
      a well-formed tree modeled by `t`, whose root parent node is `p`.  *)
  predicate is_tree (memo:pmem) (t:treel) (c p:loc) = match t with
    | Empty -> c = null
    | Node l m r -> c <> null /\ c = m /\ memo[Parent][c] = p /\
      let cl = memo[Left][c] in
      let cr = memo[Right][c] in
      (cl = null <-> cr = null) /\
      is_tree memo l cl c /\ is_tree memo r cr c
    end

  (** `footprint t` is the memory footprint of `t`, e.g the set of
      locations occuring in the tree. *)
  function footprint (t:treel) : set loc = TODO

  (** `ext s memo1 memo2` mean that the pointer fields associated to
      locations in set `s` are identical in memo1 and memo2. *)
  predicate ext (s:set loc) (memo1 memo2:pmem) =
    forall k x. mem x s -> memo1[k][x] = memo2[k][x]
  (** `unchanged memo1 memo2` mean that all pointer fields in
      `memo1` and `memo2` are identical. *)
  predicate unchanged (memo1 memo2:pmem) =
    forall k x. memo1[k][x] = memo2[k][x]
  (** `was_marked t memo1 memo2` mean that `memo2` is the update
      of `memo1` obtained by marking all elements in `t`. *)
  predicate was_marked (t:treel) (memo1 memo2:map loc bool) =
    (forall l. mem l (footprint t) -> memo2[l]) /\
    (forall l. not mem l (footprint t) -> memo2[l] = memo1[l])

  (** General extensionality property. *)
  let rec ghost ext_set (s:set loc) (memo1 memo2:pmem)
                                    (t:treel) (c p:loc) : unit
    requires { ext s memo1 memo2 }
    requires { subset (footprint t) s }
    requires { is_tree memo1 t c p }
    ensures { is_tree memo2 t c p }
    variant { t }
  = TODO

  (** Specialized for our use case. *)
  let ghost ext_cur (memo1:pmem) (t:treel) (c p:loc) : unit
    reads { memo }
    requires { ext (footprint t) memo1 memo.accessor }
    requires { is_tree memo1 t c p }
    ensures { is_tree memo.accessor t c p }
  = TODO

  (** The tree model corresponding to a given pointer is unique. *)
  let rec ghost unicity (memo:pmem) (t1 t2:treel) (c p1 p2:loc) : unit
    requires { is_tree memo t1 c p1 /\ is_tree memo t2 c p2 }
    ensures { t1 = t2 }
    variant { t1 }
  = TODO

  (** In a non-empty well formed tree, the top pointer
      cannot occur in the child subtree. Otherwise,
      their would be an infinite branch in the tree,
      which is impossible in our inductive tree setting. *)
  let ghost not_below (memo:pmem) (lf rg:treel) (c p:loc) : unit
    requires { is_tree memo (Node lf c rg) c p }
    ensures { not mem c (footprint lf) /\ not mem c (footprint rg) }
  = TODO

  (** Algorithm phases.
      `GoLeft` mean that the algorithm will try to explore the left
        subtree
      `GoRight` mean that the algorithm will explore the right subtree
      `GoBack` mean that the algorithm will go back to the parent node
      `Finish` mean that the alogrithm will exit *)
  type phase =
    | GoLeft
    | GoRight
    | GoBack
    | Finish

  function next_phase (ph:phase) : phase = TODO
  (** `rotated memo1 memo2 ph c` describe how `c` is rotated in
      `memo2` with respect to its initial position in `memo1` for
      current phase `ph`. In final phase, it is not rotated but
      null instead. *)
  predicate rotated (memo1 memo2:pmem) (ph:phase) (c:loc) =
    (forall k x. x <> c -> memo1[k][x] = memo2[k][x]) /\
    (ph <> Finish -> c <> null) /\
    match ph with
    | GoLeft -> unchanged memo1 memo2
    | GoRight -> memo2[Left][c] = memo1[Right][c] /\
        memo2[Right][c] = memo1[Parent][c] /\
        memo2[Parent][c] = memo1[Left][c]
    | GoBack -> memo1[Left][c] = memo2[Right][c] /\
        memo1[Right][c] = memo2[Parent][c] /\
        memo1[Parent][c] = memo2[Left][c]
    | Finish -> c = null
    end

end

(** In this module, we prove the algorithm by modifying
    the code to put it in recursive form. We justify that
    our limited usage of recursion makes the code equivalent
    to the one proposed in the challenge. *)
module Recursive

  use map.Map
  use bintree.Tree
  use ref.Ref
  use Memory
  use TreeShape

  (** Recursion-based proof of the algorithm.
      The principal idea is the following: in its recursive
      fashion, the algorithm is a standard tree traversal
      (which is easy to prove correct).
      Hence we nest the algorithm inside a recursive procedure
      to link it with its recursive version. However,
      the obtained algorithm does not really need the call stack
      to run. Here is how we achieve this:
      - We create a non-recursive sub-routine `bloc` corresponding to
        one turn of the while loop in the challenge's code.
        It uses an exception to simulate exit.
        Also, this sub-routine does not have any non-ghost argument,
        so calling `bloc` really amounts to advancing in the loop execution.
      - We forbids use of any side-effect in the recursive procedure
        except those obtained by calling `bloc`. Hence calling
        the recursive procedure is equivalent to run a certain
        amounts of turns in the loop execution.
        Note that since we will prove that the recursive procedure
        terminates, it might not run a finite amount of turns and diverges
        afterward.
      - After the topmost call to the recursive procedure,
        we add an infinite loop who only calls `bloc` at every turns.
        This call and the loop are enclosed in an exception catching
        construction to detect loop termination.
      Hence it is justifiable that the algorithm with
      the recursive procedure is equivalent (in the sense that
      they have the same side-effects) as an infinite loop of `bloc` calls,
      encapsulated in an exception catching expression. And this
      algorithm is evidently equivalent to the original challenge code.
    *)

  exception Stop

  let markTree (ghost t:treel) (root:loc) : unit
    (* Requires a well-formed non-empty tree *)
    requires { is_tree memo.accessor t root null /\ root <> null }
    writes { memo, non_det }
    (* Tree shape is unchanged *)
    ensures { is_tree memo.accessor t root null }
    ensures { unchanged (old memo).accessor memo.accessor }
    (* All nodes are marked. *)
    ensures { was_marked t (old memo).mark memo.mark }
  = TODO

end

(** In this module we provide a proof of the initial algorithm by
    derecursiving the previous one *)
module Iterative

  use int.Int
  use map.Map
  use map.Const
  use bintree.Tree
  use bintree.Size
  use option.Option
  use ref.Ref
  use Memory
  use TreeShape

  (** Snapshot of all relevant memory values in the program *)
  type snap = {
    pointers : pmem;
    cursor : loc;
    parent : loc;
    marks : map loc bool;
  }

  (** Stack frame in the recursive version. Fields are
      assigned as the code pointer increase. *)
  type frame = {
    (* Memory & ghost argument at call site (pc>=0). *)
    memo0 : snap;
    tree : treel;
    (* right & left trees/pointers (pc>=1) *)
    tleft : treel;
    pleft : loc;
    tright : treel;
    pright : loc;
    (* Memory after first bloc call (pc>=2) *)
    memo1 : snap;
    (* Memory after first recursive call (pc >= 4) *)
    memo2 : snap;
    (* Memory after second bloc call (pc >= 5) *)
    memo3 : snap;
    (* Memory after second recursive call (pc >= 6) *)
    memo4 : snap;
  }

  (** Find out current memory state with respect to code pointer. *)
  function frame_memo (f:frame) (pc:int) : snap = TODO

  (** Postcondition relation for `bloc` calls. *)
  predicate bloc_rel (mem0:pmem) (ph:phase) (s1 s2:snap) =
    s2.parent = s1.cursor /\ s2.cursor = s2.pointers[Parent][s2.parent] /\
    s2.marks[s2.parent] /\
    (forall l. l <> s2.parent -> s2.marks[l] = s1.marks[l]) /\
    if s1.pointers[Left][s1.cursor] = null = s1.pointers[Right][s1.cursor]
    then s2.pointers = s1.pointers
    else rotated mem0 s2.pointers (next_phase ph) s2.parent

  (** postcondition relation for recursive (`aux`) calls. *)
  predicate rec_rel (t:treel) (s1 s2:snap) =
    unchanged s1.pointers s2.pointers /\
    s2.cursor = s1.parent /\ s2.parent = s1.cursor /\
    was_marked t s1.marks s2.marks

  (** Call stack *)
  type stack =
    | Bottom
    | Running stack int frame
    | Done

  (** Describe a valid call stack. Mostly precise which relation
      between states holds. Note that in the previous version,
      Why3 did that part for us via the weakest precondition calculus. *)
  predicate is_stack (t:treel) (stop scur:snap)
                     (s:stack) (calls:option treel) =
    match s with
    | Bottom -> stop = scur /\ calls = Some t
    | Running s pc f ->
        0 <= pc <= 4 /\
        (* Correctness of caller stack. *)
        let m0 = f.memo0 in
        is_stack t stop m0 s (Some f.tree) /\
        (* Precondition for recursive call. *)
        m0.cursor <> null /\ is_tree m0.pointers f.tree m0.cursor m0.parent /\
        (* Initially obtained pointers & subtrees. *)
        f.tree = Node f.tleft m0.cursor f.tright /\
        f.pleft = m0.pointers[Left][m0.cursor] /\
        f.pright = m0.pointers[Right][m0.cursor] /\
        (* First bloc run, if completed normally. *)
        (pc >= 1 -> bloc_rel m0.pointers GoLeft m0 f.memo1 /\
                    f.pleft <> null /\ f.pright <> null) /\
        (* First recursive call. *)
        (pc >= 2 -> rec_rel f.tleft f.memo1 f.memo2) /\
        (* Second bloc run. *)
        (pc >= 3 -> bloc_rel m0.pointers GoRight f.memo2 f.memo3) /\
        (* Second recursive call. *)
        (pc >= 4 -> rec_rel f.tright f.memo3 f.memo4) /\
        (* Current memory state. *)
        frame_memo f pc = scur /\
        match calls with
        | None -> pc <> 1 /\ pc <> 3
        | Some u ->
            if pc = 1 then u = f.tleft else pc = 3 /\ u = f.tright
        end
    | Done -> rec_rel t stop scur /\ calls = None
    end

  (** Termination argument. In fully general cases, we would need
     a lexicographic ordering but here an integer size suffice. *)
  constant large_enough : int = 100
  function stack_size (st:stack) : int = TODO

  let rec lemma stack_size_pos (st:stack) : unit
    requires { exists t stop scur calls. is_stack t stop scur st calls }
    ensures { stack_size st >= 0 }
    variant { st }
  = TODO

  (** Create a stack frame for a recursive call *)
  let ghost opening (t ct:treel) (stop scur:snap) (ghost st:ref stack)
    requires { is_stack t stop scur !st (Some ct) }
    requires { is_tree scur.pointers ct scur.cursor scur.parent }
    requires { scur.cursor <> null }
    writes { st }
    ensures { is_stack t stop scur !st None }
    ensures { stack_size !st <= stack_size !(old st) +
                                large_enough * size ct }
  = TODO

  (** Remove a stack frame at end of recursive call simulation *)
  let ghost closing (t ct:treel) (stop sprev scur:snap)
                    (ghost st:ref stack) : unit
    requires { is_stack t stop sprev !st (Some ct) }
    requires { rec_rel ct sprev scur }
    writes { st }
    ensures { is_stack t stop scur !st None }
    ensures { stack_size !st < stack_size !(old st) }
  = TODO

  (** Advance code pointer when a bloc is run. Takes care to
      open/close new frame as needed. *)
  let ghost continuing (t:treel) (stop sprev scur:snap)
                       (ghost st:ref stack)
    requires { is_stack t stop sprev !st None }
    requires { match !st with
      | Bottom | Done -> false
      | Running _ pc f ->
          let ph =
            if pc = 0 then GoLeft else if pc = 2 then GoRight else GoBack in
          bloc_rel f.memo0.pointers ph sprev scur
      end }
    writes { st }
    ensures { is_stack t stop scur !st None }
    ensures { stack_size !st < stack_size !(old st) }
  = TODO

  (** The main algorithm. *)
  let markTree (ghost t:treel) (root:loc) : unit
    (* Requires a well-formed non-empty tree *)
    requires { is_tree memo.accessor t root null /\ root <> null }
    writes { memo, non_det }
    (* Tree shape is unchanged *)
    ensures { is_tree memo.accessor t root null }
    ensures { unchanged (old memo).accessor memo.accessor }
    (* All nodes are marked. *)
    ensures { was_marked t (old memo).mark memo.mark }
  = TODO

end
