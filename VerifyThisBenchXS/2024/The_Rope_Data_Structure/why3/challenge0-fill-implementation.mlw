

use int.Int
use seq.Seq
use seq.FreeMonoid

(** abstract type of characters *)
type char

(** strings are sequences of characters *)
type str = seq char

(** Ropes are implemented here as an immutable data strcuture. *)
type rope =
  | Leaf str
  | Node int rope rope

(** Function `to_str` is a logic function (keyword `function`)
    that can be used in programs as well (keyword `let`).  *)
let rec function to_str (r: rope) : str =
  match r with
  | Leaf s       -> s
  | Node _ rl rr -> to_str rl ++ to_str rr
  end

(** We introduce a `valid` predicate to express that the weight
    stored in `Node` is indeed the length of the left subrope. *)
predicate valid (r: rope) =
  match r with
  | Leaf _s       -> true
  | Node wl rl rr -> wl = length (to_str rl) && valid rl && valid rr
  end

(** Length of a rope, descending along the right spine. *)
let rec str_len (r: rope) : int
  requires { valid r }
  variant  { r }
  ensures  { result = length (to_str r) }
= TODO

(** Rope concatenation (see below for the optimized version). *)
let concat (left right: rope) : rope
  requires { valid left }
  requires { valid right }
  ensures  { valid result }
  ensures  { to_str result = to_str left ++ to_str right }
= TODO

(** Splitting a rope at a given position. *)
let rec split (r: rope) (i: int) : (left : rope, right: rope)
  requires { valid r }
  requires { 0 <= i <= length (to_str r) }
  variant  { r }
  ensures  { valid left }
  ensures  { valid right }
  ensures  { to_str r = to_str left ++ to_str right }
  ensures  { length (to_str left) = i }
= TODO

(** Deleting characters `i..i+len`. *)
let delete (r: rope) (i len: int) : rope
  requires { valid r }
  requires { 0 <= i <= length (to_str r) }
  requires { 0 <= len <= length (to_str r) - i }
  ensures  { valid result }
  ensures  { to_str result = (to_str r)[..i] ++ (to_str r)[i+len..] }
= TODO

(** Predicate `is_short` is left uninterpreted, as required. *)
val predicate is_short (r: str)

(** Inserting a rope at position `i`. *)
let insert (r: rope) (i: int) (to_insert: str) : rope
  requires { valid r }
  requires { 0 <= i <= length (to_str r) }
  ensures  { valid result }
  ensures  { to_str result = (to_str r)[..i] ++ to_insert ++ (to_str r)[i..] }
= TODO

(** The lizard examples *)

val constant char_l: char
val constant char_i: char
val constant char_z: char
val constant char_a: char
val constant char_r: char
val constant char_d: char

let constant str_lizard: str =
  cons char_l (cons char_i (cons char_z (
  cons char_a (cons char_r (cons char_d empty)))))

let constant str_lard : str =
  cons char_l (cons char_a (cons char_r (cons char_d empty)))

let test_delete (r: rope) : rope
  requires { valid r }
  requires { to_str r = str_lizard }
  ensures  { to_str result = str_lard }
= delete r 1 2

let constant str_iz : str =
  cons char_i (cons char_z empty)

let test_insert (r: rope) : rope
  requires { valid r }
  requires { to_str r = str_lard }
  ensures  { to_str result == str_lizard }
= insert r 1 str_iz
